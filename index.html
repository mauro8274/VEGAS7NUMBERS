<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roulette Tracker & Strategia</title>
    <style>
        /* CSS per Stile e Responsiveness */
        :root {
            --green-dark: #006400; /* Verde scuro, come un tavolo da roulette */
            --green-light: #90ee90; /* Verde chiaro per evidenziare */
            --red: #ff4500; /* Rosso per il testo saldo negativo */
            --black: #000000;
            --white: #ffffff;
            --gold: #ffd700;
            --gray-light: #f0f0f0;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--green-dark);
            color: var(--white);
            transition: background-color 0.5s;
        }

        .container {
            max-width: 1200px;
            margin: auto;
            padding: 10px;
        }

        /* Testo e Campi di Input */
        .header h1 {
            text-align: center;
            color: var(--gold);
            margin-bottom: 5px;
        }

        label {
            display: block;
            margin-top: 10px;
            font-weight: bold;
        }

        input[type="number"], input[type="text"] {
            width: 100%;
            padding: 12px;
            margin-top: 5px;
            margin-bottom: 10px;
            border-radius: 5px;
            border: 1px solid var(--gold);
            box-sizing: border-box;
            background-color: var(--white);
            color: var(--black);
            font-size: 1.1em;
            text-align: center;
        }

        /* Contenitori per Saldo e Scommessa */
        .info-box {
            background-color: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }

        #saldoRealTimeContainer {
            text-align: center;
        }
        
        #saldoRealTimeValue {
            font-size: 2em;
            font-weight: bold;
            display: block;
            margin-top: 5px;
            padding: 5px;
            border-radius: 5px;
            background-color: var(--white);
            color: var(--red); /* Default negativo */
        }

        #scommessaContainer {
            text-align: center;
            background-color: rgba(255, 255, 255, 0.9);
            color: var(--black);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        #scommessaContainer h3 {
            margin-top: 0;
            color: var(--green-dark);
        }

        #scommessaValue {
            font-size: 1.2em;
            font-weight: bold;
            line-height: 1.5;
            color: var(--black);
        }

        /* Tabelle */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--white);
        }

        th, td {
            padding: 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.3);
            font-size: 0.9em;
        }

        th {
            background-color: rgba(0, 0, 0, 0.5);
            color: var(--gold);
            position: sticky;
            top: 0;
        }
        
        /* Aggiungo uno stile specifico per le celle data/ora nell'archivio */
        #archiveTable td:nth-child(1), #archiveTable td:nth-child(2) { 
            font-size: 0.8em; 
            white-space: nowrap;
        }

        .highlighted-row {
            background-color: var(--green-light) !important;
            color: var(--black);
            font-weight: bold;
        }

        /* Pulsanti */
        .button-group, .button-group-archive {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            margin-bottom: 20px; 
            flex-wrap: wrap; /* Per smartphone */
        }

        button {
            flex-grow: 1;
            padding: 12px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
            font-size: 1em;
            min-width: 120px;
        }
        
        #btnArchivia { background-color: #1e90ff; color: var(--white); }
        #btnArchivia:hover { background-color: #4169e1; }

        #btnResetSession { background-color: #dc3545; color: var(--white); }
        #btnResetSession:hover { background-color: #c82333; }

        #btnToArchive { background-color: #ffc107; color: var(--black); }
        #btnToArchive:hover { background-color: #e0a800; }
        
        #btnToGameFromArchive { background-color: #28a745; color: var(--white); }
        #btnToGameFromArchive:hover { background-color: #1e7e34; }
        
        #btnResetArchive { background-color: #6c757d; color: var(--white); }
        #btnResetArchive:hover { background-color: #5a6268; }

        /* Viste (Gioco e Archivio) */
        .view {
            display: none;
        }

        #archiveView {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 10px;
            min-height: 100vh;
        }
        
        #archiveView table {
            background-color: rgba(255, 255, 255, 0.9);
            color: var(--black);
        }
        
        #archiveView th, #archiveView td {
            border-color: rgba(0, 0, 0, 0.3);
        }

        #cassaStoricaContainer {
            text-align: center;
            background-color: var(--gold);
            color: var(--black);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }

        #cassaStoricaValue {
            font-size: 2em;
            font-weight: bold;
            display: block;
        }
        
        /* Media Queries per Ottimizzazione Mobile */
        @media (max-width: 600px) {
            .container {
                padding: 5px;
            }
            input[type="number"], input[type="text"] {
                font-size: 1em;
            }
            th, td {
                padding: 6px 4px;
                font-size: 0.75em;
            }
            .info-box {
                padding: 10px;
            }
            #saldoRealTimeValue {
                font-size: 1.5em;
            }
            .button-group, .button-group-archive {
                flex-direction: column;
                gap: 5px;
            }
            button {
                min-width: 100%;
            }
            .header h1 {
                font-size: 1.5em;
            }
            /* Riduce la dimensione della data/ora sul mobile */
            #archiveTable th:nth-child(1), #archiveTable td:nth-child(1) {
                font-size: 0.6em;
            }
            #archiveTable th:nth-child(2), #archiveTable td:nth-child(2) {
                font-size: 0.6em;
            }
        }
    </style>
</head>
<body>

    <div id="gameView" class="view container">
        <div class="header">
            <img src="https://raw.githubusercontent.com/mauro8274/MANDRAKE/13cdc9b29c08d454e8ac3aee5a65679c15ad97d2/IMG_0648.png" alt="Logo Roulette Tracker" style="max-width: 90%; height: auto; display: block; margin: 0 auto; padding-top: 10px; padding-bottom: 10px;">
        </div>

        <div class="info-box">
            <label for="numeroEstratto">NUOVO NUMERO ESTRATTO (0-36):</label>
            <input type="number" id="numeroEstratto" inputmode="numeric" pattern="[0-9]*" min="0" max="36" placeholder="Inserisci numero" autofocus>
            
            <label for="puntataInput">PUNTATA (Valore di 1 Fiche in â‚¬):</label>
            <input type="number" id="puntataInput" min="0.01" step="0.01" value="0.10" placeholder="0.10">
        </div>

        <div id="saldoRealTimeContainer" class="info-box">
            <label>SALDO REAL TIME</label>
            <span id="saldoRealTimeValue">0.00â‚¬</span>
        </div>
        
        <div class="button-group">
            <button id="btnArchivia">Archivia Sessione</button>
            <button id="btnResetSession">Reset Sessione</button>
            <button id="btnToArchive">Archivio</button>
        </div>
        <div class="info-box">
            <h3>AREA DATI - Ultimi Numeri Estratti</h3>
            <table id="dataAreaTable">
                <thead>
                    <tr><th colspan="9">ULTIMI 9 NUMERI</th></tr>
                </thead>
                <tbody>
                    <tr id="lastNineNumbersRow"></tr>
                </tbody>
            </table>
        </div>

        <div id="scommessaContainer">
            <h3>SCOMMESSA (Fattori da Puntare)</h3>
            <p id="scommessaValue">Inserisci 9 numeri per calcolare...</p>
        </div>

        <div class="info-box">
            <h3>LOGICA DI GIOCO (Step di 50 Max)</h3>
            <table id="bettingTable">
                <thead>
                    <tr>
                        <th>STEP</th>
                        <th>COLORE</th>
                        <th>LINEA</th>
                        <th>DOZZINA</th>
                        <th>TOT. BET (â‚¬)</th>
                        <th>NETTO EVENTO (â‚¬)</th>
                    </tr>
                </thead>
                <tbody>
                    </tbody>
            </table>
        </div>
    </div>

    <div id="archiveView" class="view">
        <div class="container">
            <div class="header">
                <h1>ðŸ“š Archivio Sessioni</h1>
            </div>

            <div id="cassaStoricaContainer">
                <label>CASSA STORICA NETTA</label>
                <span id="cassaStoricaValue">0.00â‚¬</span>
            </div>

            <div class="info-box" style="background-color: transparent;">
                <table id="archiveTable">
                    <thead>
                        <tr>
                            <th>DATA</th>
                            <th>ORA</th>
                            <th>NETTO (â‚¬)</th>
                            <th>INVEST. INIZIALE (â‚¬)</th>
                            <th>STEP CHIUSURA</th>
                        </tr>
                    </thead>
                    <tbody>
                        </tbody>
                </table>
            </div>

            <div class="button-group-archive">
                <button id="btnToGameFromArchive">Torna al Gioco</button>
                <button id="btnResetArchive">Reset Archivio Storico</button>
            </div>
        </div>
    </div>

    <script>
        // === DATI E CONFIGURAZIONE GLOBALE ===

        // Configurazione per jsonbin.io
        // *** IMPORTANTE: PER FAR FUNZIONARE L'ARCHIVIO DEVI INSERIRE LA TUA CHIAVE REALE AL POSTO DI QUELLA SEGNAPOSTO ***
        const JSON_BIN_ID = '693c2d5343b1c97be9e984aa'; 
        // Chiave segnaposto. Se l'archiviazione non funziona, sostituiscila con la tua chiave jsonbin.io.
        const API_KEY = '$2a$10$ayP59Hfi7LkT35rikrQPk.p7vm9HN/Cko1Nwr2I0HrZyu0/1BVMLe'; 
        const API_URL = `https://api.jsonbin.io/v3/b/${JSON_BIN_ID}`;

        // Mappatura Roulette
        const ROULETTE_MAP = {
            // Colore (Rosso/Nero)
            'RED': [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36],
            'BLACK': [2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35],
            // Dozzine
            'D1': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
            'D2': [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],
            'D3': [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
            // Righe (Colonne)
            'L1': [1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34], 
            'L2': [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35], 
            'L3': [3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36]  
        };
        const MAX_STEPS = 50;
        const ANALYSIS_COUNT = 9;

        // Stato di sessione
        let sessionData = {
            extractedNumbers: [],
            currentStep: 0,
            betFactors: { color: '', line: '', dozen: '' }, // Fattori consigliati per la puntata
            betHistory: [], // Array di 50 oggetti per la tabella
            saldoRealTime: 0.00
        };

        // --- Elementi DOM ---
        const gameView = document.getElementById('gameView');
        const archiveView = document.getElementById('archiveView');
        const numeroEstrattoInput = document.getElementById('numeroEstratto');
        const puntataInput = document.getElementById('puntataInput');
        const saldoRealTimeValue = document.getElementById('saldoRealTimeValue');
        const scommessaValue = document.getElementById('scommessaValue');
        const scommessaContainer = document.getElementById('scommessaContainer');
        const dataAreaTable = document.getElementById('lastNineNumbersRow');
        const bettingTableBody = document.querySelector('#bettingTable tbody');
        const cassaStoricaValue = document.getElementById('cassaStoricaValue');
        const archiveTableBody = document.querySelector('#archiveTable tbody');

        // === FUNZIONI DI UTILITY ===

        /** Formatta un numero come valuta */
        function formatCurrency(amount) {
            return new Intl.NumberFormat('it-IT', { style: 'currency', currency: 'EUR' }).format(amount);
        }

        /** Converte una stringa Data/Ora (locale) in oggetto Date. */
        function parseDateTime(dateTimeString) {
            // Supponiamo che la stringa sia in formato 'gg/mm/aaaa hh:mm:ss'
            if (!dateTimeString) return new Date(NaN);
            
            const parts = dateTimeString.split(' ');
            if (parts.length < 2) return new Date(dateTimeString); 
            
            const dateParts = parts[0].split('/');
            const timeParts = parts[1].split(':');
            
            if (dateParts.length !== 3 || timeParts.length < 2) return new Date(dateTimeString);

            // Costruisce l'oggetto Date (Anno, Mese-1, Giorno, Ore, Minuti, Secondi)
            const y = parseInt(dateParts[2], 10);
            const m = parseInt(dateParts[1], 10) - 1;
            const d = parseInt(dateParts[0], 10);
            const h = parseInt(timeParts[0], 10);
            const min = parseInt(timeParts[1], 10);
            const s = parseInt(timeParts[2] || 0, 10); // Secondi opzionali

            return new Date(y, m, d, h, min, s);
        }

        /** Funzione per creare le righe iniziali della tabella scommesse */
        function createInitialBettingTable() {
            bettingTableBody.innerHTML = '';
            sessionData.betHistory = [];
            for (let i = 1; i <= MAX_STEPS; i++) {
                const row = bettingTableBody.insertRow();
                row.id = `stepRow-${i}`;
                row.innerHTML = `
                    <td>${i}</td>
                    <td data-col="color">0.00â‚¬</td>
                    <td data-col="line">0.00â‚¬</td>
                    <td data-col="dozen">0.00â‚¬</td>
                    <td data-col="totBet">0.00â‚¬</td>
                    <td data-col="nettoEvento">0.00â‚¬</td>
                `;
                sessionData.betHistory.push({
                    step: i,
                    colorBet: 0.00,
                    lineBet: 0.00,
                    dozenBet: 0.00,
                    totalBet: 0.00,
                    nettoEvento: 0.00,
                    isPlayed: false // Indica se la riga Ã¨ stata giocata
                });
            }
        }

        /** Aggiorna la riga dei numeri estratti */
        function updateDataAreaTable() {
            dataAreaTable.innerHTML = '';
            // Visualizza solo gli ultimi 9
            const lastNine = sessionData.extractedNumbers.slice(-ANALYSIS_COUNT); 
            
            for (let i = 0; i < ANALYSIS_COUNT; i++) {
                const number = lastNine[i] !== undefined ? lastNine[i] : '-';
                const cell = dataAreaTable.insertCell();
                cell.textContent = number;
                
                // Colora la cella con contrasto leggibile
                let bgColor = 'transparent';
                let textColor = 'var(--white)';
                if (number === '-') {
                    bgColor = 'transparent';
                    textColor = 'var(--white)';
                } else if (number === 0) {
                    bgColor = 'var(--green-light)';
                    textColor = 'var(--black)';
                } else if (ROULETTE_MAP.RED.includes(number)) {
                    bgColor = 'var(--red)';
                    textColor = 'var(--white)';
                } else if (ROULETTE_MAP.BLACK.includes(number)) {
                    bgColor = 'var(--black)';
                    textColor = 'var(--white)';
                } else {
                    bgColor = 'transparent';
                    textColor = 'var(--white)';
                }
                cell.style.backgroundColor = bgColor;
                cell.style.color = textColor;
            }
        }

        /** Resetta lo stato del gioco */
        function resetSession() {
            sessionData.extractedNumbers = [];
            sessionData.currentStep = 0;
            sessionData.betFactors = { color: '', line: '', dozen: '' };
            sessionData.saldoRealTime = 0.00;

            puntataInput.value = "0.10";
            numeroEstrattoInput.value = '';
            saldoRealTimeValue.textContent = formatCurrency(0.00);
            saldoRealTimeValue.style.color = 'var(--red)';
            scommessaValue.textContent = 'Inserisci 9 numeri per calcolare...';
            scommessaContainer.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
            scommessaContainer.style.color = 'var(--black)';

            createInitialBettingTable();
            updateDataAreaTable();
            numeroEstrattoInput.focus();
        }

        // === LOGICA DI CALCOLO STRATEGIA ===

        /** Calcola i fattori di scommessa analizzando gli ultimi 9 numeri */
        function calculateBetFactors() {
            const numbers = sessionData.extractedNumbers.slice(-ANALYSIS_COUNT);
            if (numbers.length < ANALYSIS_COUNT) return;

            const counts = {
                'RED': 0, 'BLACK': 0,
                'L1': 0, 'L2': 0, 'L3': 0,
                'D1': 0, 'D2': 0, 'D3': 0
            };

            numbers.forEach(num => {
                if (num === 0) return; // Lo zero non influenza i fattori

                // Colore
                if (ROULETTE_MAP.RED.includes(num)) counts.RED++;
                if (ROULETTE_MAP.BLACK.includes(num)) counts.BLACK++;

                // Righe
                if (ROULETTE_MAP.L1.includes(num)) counts.L1++;
                else if (ROULETTE_MAP.L2.includes(num)) counts.L2++;
                else if (ROULETTE_MAP.L3.includes(num)) counts.L3++;

                // Dozzine
                if (ROULETTE_MAP.D1.includes(num)) counts.D1++;
                else if (ROULETTE_MAP.D2.includes(num)) counts.D2++;
                else if (ROULETTE_MAP.D3.includes(num)) counts.D3++;
            });

            // 1. Logica Colore (Punta quello uscito meno)
            sessionData.betFactors.color = counts.RED < counts.BLACK ? 'RED' : 
                                            counts.BLACK < counts.RED ? 'BLACK' : 
                                            'N/A';

            // 2. Logica Riga (Punta quello uscito meno, MAI L1)
            let lineCounts = { 'L2': counts.L2, 'L3': counts.L3 };
            if (lineCounts.L2 < lineCounts.L3) {
                sessionData.betFactors.line = 'L2';
            } else if (lineCounts.L3 < lineCounts.L2) {
                sessionData.betFactors.line = 'L3';
            } else {
                sessionData.betFactors.line = 'L2'; 
            }
            
            // 3. Logica Dozzina (Punta quello uscito meno, MAI D2)
            let dozenCounts = { 'D1': counts.D1, 'D3': counts.D3 };
            if (dozenCounts.D1 < dozenCounts.D3) {
                sessionData.betFactors.dozen = 'D1';
            } else if (dozenCounts.D3 < dozenCounts.D1) {
                sessionData.betFactors.dozen = 'D3';
            } else {
                sessionData.betFactors.dozen = 'D1';
            }
            
            // Aggiorna l'interfaccia con i fattori di scommessa
            updateScommessaUI();
        }
        
        /** Mostra un pop-up di notifica con i fattori di scommessa */
        function notifyBetFactors() {
            const factors = sessionData.betFactors;
            const puntata = parseFloat(puntataInput.value) || 0.10;
            const betAmount = sessionData.betHistory[sessionData.currentStep].colorBet || puntata; // Usa l'importo calcolato per lo step 1
            
            let displayColor = factors.color === 'RED' ? 'ROSSO' : factors.color === 'BLACK' ? 'NERO' : 'Non definito';
            let displayLine = factors.line === 'L2' ? 'LINEA 2 (2-35)' : factors.line === 'L3' ? 'LINEA 3 (3-36)' : 'Non definito';
            let displayDozen = factors.dozen === 'D1' ? 'DOZZINA 1 (1-12)' : factors.dozen === 'D3' ? 'DOZZINA 3 (25-36)' : 'Non definito';

            let message = `ðŸ”” INIZIO STRATEGIA ðŸ””\n\n`;
            message += `Puntata per fattore: ${formatCurrency(puntata)}\n`;
            message += `Totale Puntata Step 1: ${formatCurrency(puntata * 3)}\n\n`;
            message += `Fattore COLORE: ${displayColor}\n`;
            message += `Fattore LINEA: ${displayLine}\n`;
            message += `Fattore DOZZINA: ${displayDozen}\n\n`;
            message += `Inserisci il prossimo numero estratto per procedere.`;
            
            alert(message);
        }

        /** Aggiorna l'interfaccia con i fattori di scommessa calcolati */
        function updateScommessaUI() {
            const factors = sessionData.betFactors;
            let displayColor = factors.color === 'RED' ? 'ROSSO' : factors.color === 'BLACK' ? 'NERO' : 'Non definito';
            let displayLine = factors.line === 'L2' ? 'LINEA 2 (2-35)' : factors.line === 'L3' ? 'LINEA 3 (3-36)' : 'Non definito';
            let displayDozen = factors.dozen === 'D1' ? 'DOZZINA 1 (1-12)' : factors.dozen === 'D3' ? 'DOZZINA 3 (25-36)' : 'Non definito';

            scommessaValue.innerHTML = `
                <span style="color: ${factors.color === 'RED' ? 'red' : factors.color === 'BLACK' ? 'black' : 'gray'}; background-color: ${factors.color === 'BLACK' ? 'white' : 'transparent'}; padding: 2px 5px; border-radius: 3px;">${displayColor}</span><br>
                ${displayLine}<br>
                ${displayDozen}
            `;
            scommessaContainer.style.backgroundColor = 'var(--gold)';
            scommessaContainer.style.color = 'var(--black)'; 
        }

        // === LOGICA DI GIOCO E AGGIORNAMENTO TABELLA ===

        /** Esegue l'analisi del numero estratto e aggiorna lo stato */
        function processExtraction(extractedNumber) {
            const currentStep = sessionData.currentStep;
            const bet = sessionData.betHistory[currentStep - 1];
            const puntataSingola = parseFloat(puntataInput.value);

            if (!bet || !bet.isPlayed) {
                console.error("Errore: Nessuna puntata attiva da processare. currentStep:", currentStep, "bet:", bet);
                return;
            }

            let winnings = 0;
            let hits = 0; // Contatore di fattori indovinati
            const betAmount = bet.colorBet; // La puntata Ã¨ uguale per tutti e 3 i fattori

            // 1. Controllo Colore (paga 1:1)
            if (bet.colorBet > 0) {
                const isRed = ROULETTE_MAP.RED.includes(extractedNumber);
                const isBlack = ROULETTE_MAP.BLACK.includes(extractedNumber);

                if (extractedNumber !== 0 && (
                    (sessionData.betFactors.color === 'RED' && isRed) ||
                    (sessionData.betFactors.color === 'BLACK' && isBlack)
                )) {
                    winnings += betAmount * 2; // Ritorno (puntata + vincita)
                    hits++;
                } else {
                    winnings += 0; // Perde la puntata
                }
            }

            // 2. Controllo Riga/Linea (paga 2:1)
            if (bet.lineBet > 0) {
                const lineMap = ROULETTE_MAP[sessionData.betFactors.line];
                if (extractedNumber !== 0 && lineMap && lineMap.includes(extractedNumber)) {
                    winnings += betAmount * 3; // Ritorno (puntata + 2*vincita)
                    hits++;
                } else {
                    winnings += 0;
                }
            }

            // 3. Controllo Dozzina (paga 2:1)
            if (bet.dozenBet > 0) {
                const dozenMap = ROULETTE_MAP[sessionData.betFactors.dozen];
                if (extractedNumber !== 0 && dozenMap && dozenMap.includes(extractedNumber)) {
                    winnings += betAmount * 3; // Ritorno (puntata + 2*vincita)
                    hits++;
                } else {
                    winnings += 0;
                }
            }

            // Calcolo NETTO EVENTO e SALDO REAL TIME
            const totalBetInRow = bet.totalBet;
            const nettoEvento = winnings - totalBetInRow;
            
            bet.nettoEvento = nettoEvento;
            sessionData.saldoRealTime = (sessionData.saldoRealTime + nettoEvento);

            updateBettingTableUI(currentStep); // Aggiorna la riga corrente
            updateSaldoRealTimeUI();

            // Logica di STOP e Prossimo step
            let nextStep = currentStep + 1;

            // Il gioco FINISCE (e viene mostrato il pop-up) solo se il Saldo Ã¨ STRETTAMENTE POSITIVO (> 0)
            if (sessionData.saldoRealTime > 0) {
                showWinPopup(sessionData.saldoRealTime);
                return; // Ferma ogni altra logica
            }

            // Calcolo importo prossima puntata (nextBetAmount)
            let nextBetAmount;
            if (hits === 0) {
                // Sconfitta: incrementa la singola puntata su ciascun fattore di una fiche
                nextBetAmount = bet.colorBet + puntataSingola;
            } else {
                // Vittoria (almeno un hit): la puntata per il prossimo step rimane invariata.
                nextBetAmount = bet.colorBet; // Mantieni l'importo della puntata precedente
            }

            // Progression check: Continua SOLO SE il saldo NON Ã¨ strettamente positivo (saldo <= 0)
            if (sessionData.saldoRealTime <= 0 && nextStep <= MAX_STEPS) { 
                setupNextStep(nextStep, nextBetAmount);
            }
            
            // Check max steps
            // L'alert viene mostrato solo se siamo in perdita (saldo < 0) e abbiamo superato gli step massimi.
            if (nextStep > MAX_STEPS && sessionData.saldoRealTime < 0) {
                alert("Raggiunto il limite massimo di 50 step. Sessione terminata in perdita. Archivia e resetta.");
            }
        }

        /** Prepara l'interfaccia per la prossima scommessa */
        function setupNextStep(step, betAmount) {
            if (step > MAX_STEPS) return;

            sessionData.currentStep = step;
            const nextBet = sessionData.betHistory[step - 1];
            const row = document.getElementById(`stepRow-${step}`);

            // Imposta i valori di puntata
            nextBet.colorBet = betAmount;
            nextBet.lineBet = betAmount;
            nextBet.dozenBet = betAmount;
            nextBet.totalBet = parseFloat((betAmount * 3).toFixed(2));
            nextBet.isPlayed = true;

            // Aggiorna la UI della nuova riga
            row.classList.add('highlighted-row');
            row.querySelector('td[data-col="color"]').textContent = formatCurrency(nextBet.colorBet);
            row.querySelector('td[data-col="line"]').textContent = formatCurrency(nextBet.lineBet);
            row.querySelector('td[data-col="dozen"]').textContent = formatCurrency(nextBet.dozenBet);
            row.querySelector('td[data-col="totBet"]').textContent = formatCurrency(nextBet.totalBet);

            // Rimuovi l'evidenziazione dalla riga precedente
            const prevRow = document.getElementById(`stepRow-${step - 1}`);
            if (prevRow) {
                prevRow.classList.remove('highlighted-row');
            }
        }

        /** Aggiorna la UI per una riga di scommessa specifica */
        function updateBettingTableUI(step) {
            const bet = sessionData.betHistory[step - 1];
            const row = document.getElementById(`stepRow-${step}`);
            
            // Aggiorna Netto Evento
            const nettoCell = row.querySelector('td[data-col="nettoEvento"]');
            nettoCell.textContent = formatCurrency(bet.nettoEvento);
            nettoCell.style.color = bet.nettoEvento >= 0 ? 'var(--green-dark)' : 'var(--red)';
            
            // La riga corrente giocata non Ã¨ piÃ¹ highlighted, la prossima lo sarÃ 
            row.classList.remove('highlighted-row');
        }

        /** Aggiorna l'interfaccia per il Saldo Real Time */
        function updateSaldoRealTimeUI() {
            const saldo = sessionData.saldoRealTime;
            saldoRealTimeValue.textContent = formatCurrency(saldo);
            saldoRealTimeValue.style.color = saldo >= 0 ? 'var(--green-dark)' : 'var(--red)';
        }
        
        /** Mostra un pop-up di vittoria */
        function showWinPopup(amount) {
            alert(`ðŸŽ‰ HAI VINTO ${formatCurrency(amount)}!! La sessione Ã¨ conclusa con profitto. Archivia per salvare i dati.`);
        }

        // === GESTIONE ARCHIVIO (JSONBIN.IO) ===
        
        /** Carica i dati dell'archivio da jsonbin.io */
        async function loadArchive() {
            try {
                const response = await fetch(API_URL, {
                    method: 'GET',
                    headers: {
                        'X-ACCESS-KEY': API_KEY
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} - ${await response.text()}`);
                }

                const data = await response.json();
                const archiveData = Array.isArray(data.record) ? data.record : [];
                
                renderArchiveTable(archiveData);
                calculateCassaStorica(archiveData);

            } catch (error) {
                console.error("Errore nel caricamento dell'archivio. Controlla la console:", error);
                renderArchiveTable([]);
                calculateCassaStorica([]);
            }
        }

        /** Salva i dati dell'archivio su jsonbin.io (sovrascrive tutto) */
        async function saveArchive() {
            if (sessionData.currentStep === 0) {
                alert("Non c'Ã¨ una sessione attiva da archiviare.");
                return;
            }
            
            // Ottiene data e ora corrente formattate
            const now = new Date();
            const datePart = now.toLocaleDateString('it-IT'); // Es: 13/12/2025
            const timePart = now.toLocaleTimeString('it-IT'); // Es: 09:16:26
            const dateTimeString = `${datePart} ${timePart}`; // Es: 13/12/2025 09:16:26

            const newEntry = {
                dataOra: dateTimeString,
                netto: parseFloat(sessionData.saldoRealTime.toFixed(2)),
                investimentoIniziale: parseFloat(puntataInput.value),
                stepChiusura: sessionData.currentStep
            };

            try {
                // 1. Carica i dati attuali
                const responseRead = await fetch(API_URL, {
                    method: 'GET',
                    headers: { 'X-ACCESS-KEY': API_KEY }
                });
                if (!responseRead.ok) throw new Error(`HTTP GET error! status: ${responseRead.status}`);
                const currentData = await responseRead.json();
                let archiveList = Array.isArray(currentData.record) ? currentData.record : [];
                
                // 2. Aggiungi la nuova entry
                archiveList.push(newEntry);
                
                // 3. Salva la lista aggiornata (sovrascrittura)
                const responseWrite = await fetch(API_URL, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-ACCESS-KEY': API_KEY
                    },
                    body: JSON.stringify(archiveList)
                });
                
                if (!responseWrite.ok) {
                    throw new Error(`HTTP PUT error! status: ${responseWrite.status} - ${await responseWrite.text()}`);
                }

                alert('Sessione archiviata con successo!');
                resetSession(); // Resetta il gioco dopo l'archiviazione
                await loadArchive(); // Ricarica l'archivio per aggiornare la cassa

            } catch (error) {
                console.error("Errore nell'archiviazione della sessione. Controlla la console:", error);
                alert("Errore nell'archiviazione. Controlla la console per i dettagli. Sessione NON salvata.");
            }
        }

        /** Resetta l'intero archivio online a un array vuoto */
        async function resetOnlineArchive() {
            if (!confirm("Sei sicuro di voler resettare TUTTO lo storico archiviato? Questa azione Ã¨ irreversibile.")) return;

            try {
                const responseWrite = await fetch(API_URL, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-ACCESS-KEY': API_KEY
                    },
                    body: JSON.stringify([{}]) // Invia un array con un oggetto vuoto per mantenere la struttura
                });
                
                if (!responseWrite.ok) {
                    throw new Error(`HTTP error! status: ${responseWrite.status} - ${await responseWrite.text()}`);
                }

                alert('Archivio storico resettato con successo!');
                loadArchive(); // Ricarica per aggiornare l'interfaccia

            } catch (error) {
                console.error("Errore nel reset dell'archivio. Controlla la console:", error);
                alert("ERRORE nel reset dell'archivio! Controlla la console per i dettagli.");
            }
        }

        /** Renderizza la tabella dell'archivio */
        function renderArchiveTable(data) {
            archiveTableBody.innerHTML = '';
            
            // Ordinamento Cronologico (dal piÃ¹ recente al piÃ¹ vecchio)
            data.sort((a, b) => {
                const dateA = parseDateTime(a.dataOra);
                const dateB = parseDateTime(b.dataOra);
                return dateB.getTime() - dateA.getTime(); // Decrescente (piÃ¹ recente prima)
            });

            data.forEach(item => {
                // Saltiamo righe non valide o vuote
                if (!item.dataOra || item.netto === undefined) return; 

                // Dividiamo Data e Ora per la visualizzazione
                const [datePart, timePart] = item.dataOra.split(' ');
                
                const row = archiveTableBody.insertRow();
                row.innerHTML = `
                    <td>${datePart || '-'}</td>
                    <td>${timePart || '-'}</td>
                    <td style="color: ${item.netto >= 0 ? 'var(--green-dark)' : 'var(--red)'};">${formatCurrency(item.netto)}</td>
                    <td>${formatCurrency(item.investimentoIniziale)}</td>
                    <td>${item.stepChiusura}</td>
                `;
            });
        }
        
        /** Calcola e aggiorna la Cassa Storica */
        function calculateCassaStorica(data) {
            // Filtra per assicurarsi che 'netto' sia un numero valido prima di sommare
            const totalNet = data.reduce((sum, item) => sum + (parseFloat(item.netto) || 0), 0);
            cassaStoricaValue.textContent = formatCurrency(totalNet);
            cassaStoricaValue.style.backgroundColor = totalNet >= 0 ? 'var(--green-light)' : 'var(--red)';
            cassaStoricaValue.style.color = totalNet >= 0 ? 'var(--black)' : 'var(--white)';
        }

        // === GESTIONE EVENTI ===

        /** Funzione centrale per processare il numero estratto, richiamata da diversi eventi. */
        function handleNewNumber() {
            const num = parseInt(numeroEstrattoInput.value);
            const puntata = parseFloat(puntataInput.value);

            // Controllo validitÃ  dell'input
            if (isNaN(num) || num < 0 || num > 36 || isNaN(puntata) || puntata <= 0) {
                // Mostra l'errore solo se l'utente ha provato ad inserire un valore non vuoto
                if (numeroEstrattoInput.value.trim() !== '') {
                    alert('Inserisci un numero valido (0-36) e una puntata iniziale valida.');
                }
                return;
            }
            
            // Logica di processamento
            sessionData.extractedNumbers.push(num);
            numeroEstrattoInput.value = ''; // Pulisce il campo

            if (sessionData.extractedNumbers.length >= ANALYSIS_COUNT) {
                updateDataAreaTable(); // Aggiorna i 9 numeri
                
                // Dopo il 9Â° numero (o se Ã¨ la prima giocata dopo il 9Â°)
                if (sessionData.currentStep === 0) {
                    calculateBetFactors();
                    setupNextStep(1, puntata); // Inizia il primo step con puntata iniziale
                    notifyBetFactors(); // MOSTRA IL POP-UP
                } else {
                    // Dal 10Â° numero in poi (o step successivi)
                    processExtraction(num);
                    calculateBetFactors(); // Ricalcola i fattori per il prossimo giro
                }
            } else {
                updateDataAreaTable();
            }
        }

        // 1. Listener per tastiera desktop (tasto Invio)
        numeroEstrattoInput.addEventListener('keydown', function(event) {
            // Controlla per 'Enter' o keyCode 13 (per maggiore compatibilitÃ )
            if (event.key === 'Enter' || event.keyCode === 13) {
                event.preventDefault(); // Impedisce l'invio del form
                handleNewNumber();
            }
        });

        // 2. Listener per tastiera mobile (evento 'blur' quando si preme 'Done' o si tocca fuori)
        numeroEstrattoInput.addEventListener('blur', function() {
            // Processa solo se c'Ã¨ un valore valido nel campo
            if (this.value.trim() !== '') {
                handleNewNumber();
            }
        });

        // Pulsanti di navigazione
        document.getElementById('btnToArchive').addEventListener('click', () => {
            gameView.style.display = 'none';
            archiveView.style.display = 'block';
            loadArchive(); // Carica l'archivio senza controllo API key
        });

        document.getElementById('btnToGameFromArchive').addEventListener('click', () => {
            archiveView.style.display = 'none';
            gameView.style.display = 'block';
            numeroEstrattoInput.focus();
        });

        // Pulsanti azioni
        document.getElementById('btnArchivia').addEventListener('click', saveArchive);
        document.getElementById('btnResetSession').addEventListener('click', () => {
             if (confirm("Sei sicuro di voler resettare la sessione attuale?")) {
                 resetSession();
             }
        });
        document.getElementById('btnResetArchive').addEventListener('click', resetOnlineArchive);


        // Inizializzazione all'apertura della pagina
        window.onload = () => {
            resetSession();
            gameView.style.display = 'block';
        };
    </script>
</body>
</html>